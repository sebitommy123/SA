HIGH PRIO

`[]` for lists, * is the item

"has multiple conflicting definitions from different sources." has to be better
   Specially for links, but also short lists and dicts

Autocomplete

I think all operators should instantly return AbsorbingNone if passed in as context (or arguments?)

comparing Link types with == is broken
    need a way of debugging links

lists of Objects need to be turned into ObjectLists

named contexts


MID PRIO

Fix GroupObjects function, it is stupid and doesn't consider Type

contrl+C should cancel current command, not exit shell

I want to create an app that can run multiple providers
    As such, you should be able to define multiple providers from just one python file and pass them on
    multiple_providers will then just run them all in separate processes and create a UI dashboard for you to see how they're doing

if 0 objects from a provider, show text in red

hard to figure out what sources exist rn, only says provider names

if AbsorbingNone is the final result, make a prettier result like "Nothing"

Foreach operator {}
    {.name = .name.to_upper()}
    also just {.name.to_upper()}
    which is {.set_field("name", .get_field("name").to_upper()}
    string formatting
    {.name = f'{.name}_'}
    if statements
        {.name = if(.name.startswith('_'), f'{.name}_', .name)}
        which is {.name = f'{.name}_' if .name.startswith('_') else .name}

"method types", methods that can run on a given type, which are really just links basically but don't need to be added to all the objects manually.

Annotations for objects and fields.

aliases, including aliases that become whole queries and aliases that can take in arguments
e.g. map_port AA -> [.port == 'AA'] using a simple template

Takes too long to downlosd data from SAPs

sa-shell should store data so opening it is fast and it refreshes in background

test mode for SAPs so it returns output and doesn't start the server

AND and OR don't work yet bc of operator precedence not being a thing
 1. Should also add ()

 a way to list all providers and exposed sources


LOW PRIO

Context-less functions should not have a dot "." at the beginning. These functions feed context straight through to their arguments. E.g. equals() feels wrong to type with a "." for a good reason.

Better indexing, not hardcoded to types and Ids. Have to give it more thought.
    Needs to be able to be copied to new ObjectLists after filtering or selecting, etc...

autocomplete / suggest

an optimization: query caching, so if you run the same thing twice, it remembers the result. Or if you run A, it remembers it so A.B runs fast

notion of data "age"

concat object lists, "+" works

more operators: >< .any(), .counts() -> count of each thing in list

perhaps should be powered by Pandas for C acceleration?

should have "workspaces" with saved commands, etc...






--------
Some shits going down here
host#<application[.enabled == "Disabled"].host_name>
this creates a new query for each result of the previous query, and returns a new object list
which I think should be equivalent to
application[.enabled == "Disabled"].host_name.replace_each(host#<>)
but {} is kinda our syntax for replace each so
application[.enabled == "Disabled"].host_name{host#<>)
to preserve the app, you could do
application[.enabled == "Disabled"]{.host_name.replace(host#<>)}

application{APP => .host_name = *host[.name == APP.host_name]}
equivalent to
application{APP => APP.host_name = *host[.name == APP.host_name]}


EXAMPLE:
get apps with the same id as their hosts
app[host[.apps.includes("lol")].name == .name]

maybe instead of passing down "all_data", there should be a first-class concept of "context-stack"
    that is, every time a function mutates the context, it actually just gets added to the stack:
        when a function returns something in a chain, if there is something after it in the chain, the return value will be added to the context stack. all functions then just use the latest thing in the context stack by default.
        when a function executes a chain passed in as an argument, passing in custom context, it also just adds the custom context to the stack and passes in the stack.
    then, .pop_context(n) (special operator) can be used to pop a certain number of contexts during a chain. the shorthand is *, which calls .pop_context(-1), popping all the way back to all_data. you can then also do *[-1] which calls .pop_context(1), etc... 
        for example app[#host_01.name == .name]
            this won't work because #lol will execute on just the app, returning nothing.
            instead: app[*#lol.name == .name]
                this runs #lol on all_data
        for example app#mds_01.host.apps[.core == *[-2].sys_core]
            this will probably grab the host in *[-2]
        ofc this syntax is super ugly and basically useless, so probably I should only support a named context stack. i.e. we only keep the contexts you name
        for example app#mds_01.host=>HOST.apps[.core == HOST.sys_core]
            so this way, the context_stack just has "*" by default, and then other capitalized saved contexts
            the => operator is a special operator .add_context_to_stack("HOST") which adds to the stack
        for example app[host[HOST => .apps.includes(HOST.name)].name == .name]
            this is an example of naming the context in operators that craft new syntax (the filter operator literally picks what context what to pass into the arg operator, but will also pass the context_stack with the extra named argument if you choose to)
        NEW IDEA
            operators now only take in context_stack (and arguments ofc), no context, no all_data
            then the context_stack always has:
                all_data (returns the original complete object list)
                current_context (returns the latest object list, likely created by the previous operator in the chain)
                named_contexts (a dict of name => context)
                ONLY named_contexts is editable (add-only) via a .add_named_context() method. everything else is read-only
            what operators return always becomes the current_context if in a chain
                the return is usually just used as the context by the next operator
                sometimes if an operator is directly running this other operator (e.g. filter), it can use that return value directly
            then, there's the .add_named_context(name) operator
                which just adds to named_contexts the current_context with the name
            and there's the .get_named_context(name) operator
                which just returns the named context! which ofc then becomes the current_context if in a chain :)
        
            
        
            

-------
SELECT operator overhaul
which can also be a MAP now

 1. Grab a set of fields from all objects, keep only those alongside id/type/source still there
 2. Replace each object with the result of a expression ran on the object
 3. Replace each object's attribute with the result of a expression

SELECT mode:
    app[["name", "host"]]

FOREACH mode:
    app{.name = "lol", .neighbors = .host.apps.count()}

MAP mode:
    app.map(.name)

Supports named context ofc
application{APP => APP.host_name = *host[.name == APP.host_name]}

